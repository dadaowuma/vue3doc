import{_ as a,c as e,$ as i,o as t}from"./chunks/framework.BVElzs7h.js";const c=JSON.parse('{"title":"Estado","description":"","frontmatter":{},"headers":[],"relativePath":"ptbr/guide/state.md","filePath":"ptbr/guide/state.md"}'),n={name:"ptbr/guide/state.md"};function o(p,s,l,r,d,h){return t(),e("div",null,s[0]||(s[0]=[i(`<h1 id="estado" tabindex="-1">Estado <a class="header-anchor" href="#estado" aria-label="Permalink to &quot;Estado&quot;">​</a></h1><h2 id="arvore-unica-de-estado" tabindex="-1">Árvore Única de Estado <a class="header-anchor" href="#arvore-unica-de-estado" aria-label="Permalink to &quot;Árvore Única de Estado&quot;">​</a></h2><div class="scrimba"><a href="https://scrimba.com/p/pnyzgAP/cWw3Zhb" target="_blank" rel="noopener noreferrer">Tente esta lição no Scrimba</a></div><p>Vuex usa uma <strong>única árvore de estado</strong> - ou seja, este único objeto contém todo o estado da sua aplicação e serve como &quot;fonte única da verdade&quot;. Isso também significa que normalmente você terá apenas uma <em>store</em> para cada aplicação. Uma única árvore de estado facilita a localização de uma parte específica do estado e nos permite capiturar facilmente momentos do estado atual da aplicação para fins de depuração.</p><p>A árvore única de estado não entra em conflito com a modularidade - em capítulos posteriores, discutiremos como dividir seu estado e mutações em sub-módulos.</p><p>Os dados que você armazena no Vuex seguem as mesmas regras que o <code>data</code> em uma instância do Vue, ou seja, o objeto de estado deve ser simples. <strong>Veja também:</strong> <a href="https://v3.vuejs.org/api/options-data.html#data-2" target="_blank" rel="noreferrer">Vue#data</a>.</p><h2 id="obtendo-o-estado-vuex-nos-componentes-vue" tabindex="-1">Obtendo o Estado Vuex nos Componentes Vue <a class="header-anchor" href="#obtendo-o-estado-vuex-nos-componentes-vue" aria-label="Permalink to &quot;Obtendo o Estado Vuex nos Componentes Vue&quot;">​</a></h2><p>Então, como exibimos o estado dentro do <em>store</em> em nossos componentes Vue? Como os <em>stores</em> Vuex são reativos, a maneira mais simples de &quot;recuperar&quot; o estado dele é simplesmente retornar algum estado do <em>store</em> de dentro de um <a href="https://vuejs.org/guide/computed.html" target="_blank" rel="noreferrer">dado computado</a>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vamos criar um componente de Contador</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`&lt;div&gt;{{ count }}&lt;/div&gt;\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.state.count</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Sempre que o <code>store.state.count</code> mudar, fará com que o dado computado seja reavaliado e ative as atualizações de DOM associadas.</p><p>No entanto, esse padrão faz com que o componente dependa do <em>singleton</em> do <em>store</em> global. Ao usar um sistema de módulo, ele precisa importar o <em>store</em> em todos os componentes que usam o estado do <em>store</em> e também requer dados fictícios (ou <em>mocking</em>) ao testar o componente.</p><p>O Vuex &quot;injeta&quot; o <em>store</em> em todos os componentes filhos do componente raiz através do sistema de <em>plugins</em> do Vue e estará disponível neles como <code>this.$store</code>. Vamos atualizar nossa implementação do <code>Counter</code>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`&lt;div&gt;{{ count }}&lt;/div&gt;\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$store.state.count</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="o-metodo-auxiliar-mapstate" tabindex="-1">O Método Auxiliar <code>mapState</code> <a class="header-anchor" href="#o-metodo-auxiliar-mapstate" aria-label="Permalink to &quot;O Método Auxiliar \`mapState\`&quot;">​</a></h2><div class="scrimba"><a href="https://scrimba.com/p/pnyzgAP/c8Pz7BSK" target="_blank" rel="noopener noreferrer">Tente esta lição no Scrimba</a></div><p>Quando um componente precisa usar várias propriedades ou <em>getters</em> de estado do <em>store</em>, declarar todas esses dados computados pode ser repetitivo e verboso. Para lidar com isso, podemos fazer uso do método auxiliar <code>mapState</code> que gera funções <em>getter</em> computadas para nós, economizando algumas linhas de código:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// em builds completos, os métodos auxiliares são expostos como Vuex.mapState</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { mapState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vuex&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // As arrow functions (ou funções de seta) podem tornar o código muito sucinto!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // passar o valor da String &#39;count&#39; é o mesmo que \`state =&gt; state.count\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    countAlias: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;count&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // para acessar o estado local com \`this\`, uma função normal deve ser usada</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    countPlusLocalState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.localCount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Também podemos passar um <em>Array</em> de <em>Strings</em> para <code>mapState</code> quando o nome de um dado computado mapeado é o mesmo que um nome de árvore secundária do estado.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // mapeia this.count para store.state.count</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;count&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><h2 id="objeto-spread-operator" tabindex="-1">Objeto Spread Operator <a class="header-anchor" href="#objeto-spread-operator" aria-label="Permalink to &quot;Objeto Spread Operator&quot;">​</a></h2><p>Observe que <code>mapState</code> retorna um objeto. Como usá-lo em combinação com outros dados computados locais? Normalmente, teríamos que usar um utilitário para fundir vários objetos em um para que possamos passar o objeto final para <code>computed</code>. No entanto, com o <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noreferrer">objeto spread operator</a>, podemos simplificar muito a sintaxe:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  localComputed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // mistura isso no objeto externo com o objeto spread operator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="componentes-ainda-podem-ter-um-estado-local" tabindex="-1">Componentes Ainda Podem Ter Um Estado Local <a class="header-anchor" href="#componentes-ainda-podem-ter-um-estado-local" aria-label="Permalink to &quot;Componentes Ainda Podem Ter Um Estado Local&quot;">​</a></h2><p>Usar Vuex não significa que você deve colocar <strong>todo</strong> o estado no Vuex. Embora colocar mais estado no Vuex torna suas mutações de estado mais explícitas e depuráveis, às vezes também pode tornar o código mais verboso e indireto. Se uma parte do estado pertencer estritamente a um único componente, não haverá problema em deixá-lo apenas como um estado local. Você deve pesar os prós e contras e tomar decisões que atendam às necessidades de desenvolvimento da sua aplicação.</p>`,24)]))}const m=a(n,[["render",o]]);export{c as __pageData,m as default};
