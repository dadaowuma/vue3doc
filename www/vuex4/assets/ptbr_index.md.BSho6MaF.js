import{_ as a,a as s}from"./chunks/vuex.BBU_wvQb.js";import{_ as i,c as o,$ as n,o as t}from"./chunks/framework.BVElzs7h.js";const g=JSON.parse('{"title":"O que é Vuex?","description":"","frontmatter":{},"headers":[],"relativePath":"ptbr/index.md","filePath":"ptbr/index.md"}'),r={name:"ptbr/index.md"};function p(d,e,l,m,c,u){return t(),o("div",null,e[0]||(e[0]=[n(`<h1 id="o-que-e-vuex" tabindex="-1">O que é Vuex? <a class="header-anchor" href="#o-que-e-vuex" aria-label="Permalink to &quot;O que é Vuex?&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">NOTE</p><p>Esta documentação é para o Vuex 4, que funciona com Vue 3. Se você está procurando a documentação para o Vuex 3, que funciona com Vue 2, <a href="https://vuex.vuejs.org/ptbr/" target="_blank" rel="noreferrer">por favor, confira aqui</a>.</p></div><p>O Vuex é um <strong>padrão de gerenciamento de estado + biblioteca</strong> para aplicações Vue.js. Ele serve como um <em>store</em> centralizado para todos os componentes em uma aplicação, com regras garantindo que o estado só possa ser mutado de forma previsível.</p><h2 id="o-que-e-um-padrao-de-gerenciamento-do-estado" tabindex="-1">O que é um &quot;Padrão de Gerenciamento do Estado&quot;? <a class="header-anchor" href="#o-que-e-um-padrao-de-gerenciamento-do-estado" aria-label="Permalink to &quot;O que é um &quot;Padrão de Gerenciamento do Estado&quot;?&quot;">​</a></h2><p>Vamos começar com uma aplicação simples em Vue, um contador:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // state</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // view</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;div&gt;{{ count }}&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  \`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // actions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Counter).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>É uma aplicação independente com as seguintes partes:</p><ul><li>O <strong>estado</strong> (<em>state</em>), que é a fonte da verdade que direciona nossa aplicação;</li><li>A <strong><em>view</em></strong>, que é apenas um mapeamento declarativo do <strong>estado</strong>;</li><li>As <strong>ações</strong> (<em>actions</em>), que são as possíveis maneiras pelas quais o estado pode mudar em reação às interações dos usuários da <strong><em>view</em></strong>.</li></ul><p>Esta é uma representação simples do conceito de &quot;fluxo de dados unidirecional&quot; (<em>one-way</em>):</p><p style="text-align:center;margin:2em;"><img style="width:100%;max-width:450px;" src="`+a+'"></p><p>No entanto, a simplicidade é rapidamente descartada quando temos <strong>vários componentes que compartilham um estado comum</strong>:</p><ul><li>Múltiplas <em>views</em> que podem depender do mesmo pedaço de estado.</li><li>Ações de diferentes <em>views</em> que podem precisar alterar o mesmo pedaço de estado.</li></ul><p>Para o problema um, passar tudo via propriedades (<em>props</em>) pode ser entediante para componentes profundamente aninhados e simplesmente não funciona para componentes irmãos. Para o problema dois, muitas vezes nos encontramos recorrendo a soluções como buscar referências diretas de instância pai / filho ou tentar mudar e sincronizar várias cópias do estado por meio de eventos. Ambos os padrões são frágeis e levam rapidamente a códigos impossíveis de manter.</p><p>Então, por que não extraímos o estado compartilhado dos componentes, e o gerenciamos em um <em>singleton</em> global? Com isso, nossa árvore de componentes se torna uma grande &quot;<em>view</em>&quot;, e qualquer componente pode acessar o estado ou acionar ações, não importando onde elas estejam na árvore!</p><p>Além disso, ao definir e separar os conceitos envolvidos no gerenciamento do estado e aplicar regras que mantêm a independência entre as <em>views</em> e os estados, damos ao nosso código mais estrutura e capacidade de manutenção.</p><p>Esta é a ideia básica por trás do Vuex, inspirado no <a href="https://facebook.github.io/flux/docs/overview" target="_blank" rel="noreferrer">Flux</a>, <a href="http://redux.js.org/" target="_blank" rel="noreferrer">Redux</a> e <a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noreferrer">The Elm Architecture</a>. Ao contrário dos outros padrões, o Vuex também é uma implementação da biblioteca adaptada especificamente para o Vue.js aproveitar as vantagens de seu sistema de reatividade granular para atualizações eficientes.</p><p>Se você quiser aprender Vuex de uma forma interativa, você pode conferir esse <a href="https://scrimba.com/g/gvuex" target="_blank" rel="noreferrer">curso de Vuex no Scrimba</a>, que oferece uma mistura de <em>screencast</em> e <em>playground</em> de código em que você pode pausar e brincar com o código a qualquer momento.</p><p><img src="'+s+'" alt="vuex"></p><h2 id="quando-usar-o-vuex" tabindex="-1">Quando usar o Vuex? <a class="header-anchor" href="#quando-usar-o-vuex" aria-label="Permalink to &quot;Quando usar o Vuex?&quot;">​</a></h2><p>Embora o Vuex nos ajude a lidar com o gerenciamento de estado compartilhado, ele também vem com o custo de mais conceitos e códigos repetitivos. É uma escolha de prós e contras entre produtividade de curto e longo prazo</p><p>Se você nunca construiu um SPA em grande escala e for direto para o Vuex, ele pode parecer verboso e desanimador. Isso é perfeitamente normal - se a sua aplicação é simples, você provavelmente ficará bem sem o Vuex. Um simples <a href="https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch" target="_blank" rel="noreferrer">store pattern</a> pode ser tudo que você precisa. Mas, se você está criando um SPA de médio a grande porte, é provável que tenha encontrado situações que fazem você pensar em como lidar melhor com o estado fora de seus componentes Vue, e o Vuex será naturalmente o próximo passo para você. Há uma boa citação de Dan Abramov, o autor do Redux:</p><blockquote><p>As bibliotecas Flux são como óculos: você saberá quando precisar delas.</p></blockquote>',22)]))}const E=i(r,[["render",p]]);export{g as __pageData,E as default};
