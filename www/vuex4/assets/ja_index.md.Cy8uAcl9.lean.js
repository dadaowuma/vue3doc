import{_ as a,a as i}from"./chunks/vuex.BBU_wvQb.js";import{_ as n,c as e,$ as t,o as l}from"./chunks/framework.BVElzs7h.js";const E=JSON.parse('{"title":"Vuex とは何か？","description":"","frontmatter":{},"headers":[],"relativePath":"ja/index.md","filePath":"ja/index.md"}'),p={name:"ja/index.md"};function r(h,s,k,o,u,d){return l(),e("div",null,s[0]||(s[0]=[t(`<h1 id="vuex-とは何か" tabindex="-1">Vuex とは何か？ <a class="header-anchor" href="#vuex-とは何か" aria-label="Permalink to &quot;Vuex とは何か？&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">注意</p><p>これは、Vue 3 で動作する Vuex 4 のためのドキュメントです。Vue 2 で動作する Vuex 3 のドキュメントをお探しの方は、<a href="https://vuex.vuejs.org/ja/" target="_blank" rel="noreferrer">こちらをご覧ください</a>。</p></div><p>Vuex は Vue.js アプリケーションのための <strong>状態管理パターン + ライブラリ</strong>です。 これは予測可能な方法によってのみ状態の変異を行うというルールを保証し、アプリケーション内の全てのコンポーネントのための集中型のストアとして機能します。</p><h2 id="状態管理パターン-とはなんですか" tabindex="-1">&quot;状態管理パターン&quot;とはなんですか？ <a class="header-anchor" href="#状態管理パターン-とはなんですか" aria-label="Permalink to &quot;&quot;状態管理パターン&quot;とはなんですか？&quot;">​</a></h2><p>単純な Vue で作られたカウンターアプリをみてみましょう:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // state</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // view</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;div&gt;{{ count }}&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  \`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // actions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Counter).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>これはいくつかの要素をアプリ自身に含んでいます:</p><ul><li><strong>状態</strong>、これは私達のアプリを動かす信頼できる情報源(the source of truth)です。</li><li><strong>ビュー</strong>、これは<strong>状態</strong>のただの宣言的なマッピングです。</li><li><strong>アクション</strong>、これは<strong>ビュー</strong>からのユーザー入力に反応して、状態の変更を可能にする方法です。</li></ul><p>これらは&quot;単方向データフロー&quot;のコンセプトの極めてシンプルな責務です:</p><p style="text-align:center;margin:2em;"><img style="width:100%;max-width:450px;" src="`+a+'"></p><p>しかし、単純さは、<strong>共通の状態を共有する複数のコンポーネントを持ったときに</strong>、すぐに破綻します:</p><ul><li>複数のビューが同じ状態に依存することがあります。</li><li>異なるビューからのアクションで、同じ状態を変更する必要があります。</li></ul><p>一つ目は、プロパティ (props) として深く入れ子になったコンポーネントに渡すのは面倒で、兄弟コンポーネントでは単純に機能しません。二つ目は、親子のインスタンスを直接参照したり、イベントを介して複数の状態のコピーを変更、同期することを試みるソリューションに頼っていることがよくあります。これらのパターンは、いずれも脆く、すぐにメンテナンスが困難なコードに繋がります。</p><p>では、コンポーネントから共有している状態を抽出し、それをグローバルシングルトンで管理するのはどうでしょうか？ これにより、コンポーネントツリーは大きな &quot;ビュー&quot; となり、どのコンポーネントもツリー内のどこにあっても状態にアクセスしたり、アクションをトリガーできます!</p><p>さらに、状態管理に関わる概念を定義、分離し、特定のルールを敷くことで、コードの構造と保守性を向上させることができます。</p><p>これが Vuex の背景にある基本的なアイディアであり、<a href="https://facebook.github.io/flux/docs/overview" target="_blank" rel="noreferrer">Flux</a>、 <a href="http://redux.js.org/" target="_blank" rel="noreferrer">Redux</a> そして <a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noreferrer">The Elm Architecture</a>から影響を受けています。 他のパターンと異なるのは、Vuex は効率的な更新のために、Vue.js の粒度の細かいリアクティビティシステムを利用するよう特別に調整して実装されたライブラリだということです。</p><p>あなたがもし対話型の方法でVuexを学びたいのであれば、<a href="https://scrimba.com/g/gvuex" target="_blank" rel="noreferrer">Scrimba</a>のVuexコースをぜひ試してみてください。</p><p><img src="'+i+'" alt="vuex"></p><h2 id="いつ、vuexを使うべきでしょうか" tabindex="-1">いつ、Vuexを使うべきでしょうか？ <a class="header-anchor" href="#いつ、vuexを使うべきでしょうか" aria-label="Permalink to &quot;いつ、Vuexを使うべきでしょうか？&quot;">​</a></h2><p>Vuex は、共有状態の管理に役立ちますが、さらに概念やボイラープレートのコストがかかります。これは、短期的生産性と長期的生産性のトレードオフです。</p><p>もし、あなたが大規模な SPA を構築することなく、Vuex を導入した場合、冗長で気が遠くなるように感じるかもしれません。そう感じることは全く普通です。あなたのアプリがシンプルであれば、Vuex なしで問題ないでしょう。単純な <a href="https://v3.ja.vuejs.org/guide/state-management.html#simple-state-management-from-scratch" target="_blank" rel="noreferrer">ストアパターン</a> が必要なだけかもしれません。しかし、今あなたが中規模から大規模の SPA を構築しているなら、Vue コンポーネントの外の状態をもっとうまく扱えないか考えなくてはならない状況にあるかもしれません。その場合 Vuex は次のステップとして最適でしょう。これは Redux の作者、Dan Abramov からの良い引用です:</p><blockquote><p>Flux ライブラリは眼鏡のようなものです: あなたが必要な時にいつでも分かるのです。</p></blockquote>',22)]))}const x=n(p,[["render",r]]);export{E as __pageData,x as default};
